# IA-HASH Roadmap — Version 2.0
A clean, universal, provider-independent evolution of the IA-HASH protocol.

This document describes:
- Where IA-HASH comes from (v1.x)
- Why v2.0 exists
- What v2.0 delivers
- The future direction of the protocol and ecosystem

---

## 1. Background: What IA-HASH Was in v1.x

IA-HASH began as a system to verify **prompt + response** pairs generated by AI models.  
Versions 1.0–1.2 introduced:

- A protocol based on SHA-256 and Ed25519 signatures  
- Two modes:  
  - **PAIR** (manual prompt + response)  
  - **CONVERSATION** (extraction from LLM shared URLs)  
- Extractors for ChatGPT share links  
- A multiple-page web UI  
- A SQLite database for prompts/sequences  
- HMAC-based prompt validation  
- Notarization of prompt–response integrity

The concept worked, but the architecture became:
- Too LLM-centric  
- Dependent on OpenAI/Claude backend APIs for authenticity  
- Complex and hard to extend cleanly  
- Confusing for contributors (too many concepts, mixed layers)

However, the **core idea** hidden underneath was far more general:

> IA-HASH is fundamentally a protocol for verifying the integrity of a *relationship between two elements*.

This insight is what leads to v2.0.

---

## 2. Philosophy of IA-HASH v2.0

Version 2.0 reframes IA-HASH into its true form:

> **IA-HASH v2.0 is a universal cryptographic protocol for verifying a Pair (PAR 1, PAR 2).**

This Pair can represent any meaningful relationship:

- Text + Text  
- File + File  
- Contract + Company  
- Author + Work  
- Scientist + Report  
- Original + Translation  
- Code + Commit Message  
- Prompt + Response  
- Dog + Owner  
- Property + Owner  
- Document + Signer  
- etc.

### Core principles of v2
- Provider-agnostic  
- AI-agnostic  
- Minimal, elegant, auditable core  
- Strong separation of concerns  
- Extensible via adapters  
- Web/API fully rewritten and simplified  
- v1.x preserved in `legacy/` (nothing lost, but not blocking progress)

---

## 3. Goals of IA-HASH v2.0

### 3.1. Protocol Goals
- Define the **IAHASH-2.0** specification  
- Introduce generic fields:  
  - `par1`, `par2`  
  - `par1_hash`, `par2_hash`, `pair_hash`  
- Establish a canonical document structure  
- Define verification rules and error codes  
- Keep cryptography simple and robust: SHA-256 + Ed25519

### 3.2. Architecture Goals
- Create a new clean tree:
iahash/
  core/        → protocol, hashing, signing, verification
  adapters/    → integrations (ChatGPT, Claude, files…)
  storage/     → optional DB layer
  api/           → minimal FastAPI (v2)
  web/           → single-page UI
  legacy/        → all v1.x functionality
  docs/          → v2 documentation

### 3.3. Product Goals
- Replace multi-page UI with a **single clean landing page**:
  - What is IA-HASH?
  - Issue a Pair (PAR 1 / PAR 2)
  - Verify an IA-HASH document
  - Links to Docs & GitHub
  - Section: “LLM Authenticity — Coming Soon”

- Provide a stable, easy-to-understand MVP  
- Enable contributors to join without confusion  
- Prepare future integration layers cleanly

---

## 4. What Changes from v1.2 to v2.0

### 4.1. The Protocol
**v1.2** was oriented around:
- prompt  
- response  
- h_prompt  
- h_response  
- h_total  
- model metadata  
- conversation URLs  

**v2.0** replaces all AI-centric logic with a general Pair structure:
- `par1`: raw element 1 (text or file ref)  
- `par2`: raw element 2  
- `par1_hash`  
- `par2_hash`  
- `pair_hash`  
- generic metadata block  
- issuer signature  
- no assumptions about AI providers

### 4.2. The Architecture
**v1.2** mixed:
- core hashing logic  
- extractors  
- prompts & sequences  
- UI & backend  
- database schema tied to prompts  

**v2.0** introduces strict modular separation:
- `core` → protocol logic only  
- `adapters` → extractors (optional)  
- `api` → minimal FastAPI  
- `web` → minimal UI  
- `legacy` → everything v1.2 preserved

### 4.3. Deployment & Tooling
Nothing changes for deployment:
- Same Dockerfile  
- Same Coolify service  
- Only branch changes from `v1.2` → `v2` when ready  

This keeps integration friction near zero.

---

## 5. Deliverables for Version 2.0

### 5.1. Core Package (`iahash/core`)
- `Pair` model  
- text normalization  
- hashing system  
- Ed25519 signing and verification  
- IA-HASH document builder  
- verification engine  
- error classes and codes  
- protocol constants  

### 5.2. API (`api/main.py`)
Endpoints:

- `POST /api/issue/pair`  
  → Create IA-HASH document from PAR 1 + PAR 2  
- `POST /api/verify`  
  → Verify full IA-HASH document  
- `GET /public-key`  
  → Public Ed25519 key of issuer  
- `GET /health`  
  → Status check  

### 5.3. Web (Single Page)
- Modern, simple landing page  
- Issue Pair form  
- Verify IA-HASH form  
- “Coming Soon: LLM Authenticity” section  
- Links to documentation and GitHub  

### 5.4. Documentation
- `PROTOCOL_2.0.md`  
- `ARCHITECTURE_2.0.md`  
- `ROADMAP_v2.md` (this file)  
- `PAIRS_SPEC.md`  
- Updated `README.md` (English, concise, developer-friendly)

### 5.5. Legacy Preservation
A new folder:
legacy/
  api_v1/
  iahash_v1/
  web_v1/
  docs_v1/
  db_v1/

All v1.x functionality remains untouched for reference.

---

## 6. Future Roadmap Beyond v2.0

### 6.1. v2.1 — File-Based Pairs
- Support binary hashing  
- Upload interface for PAR 1 / PAR 2  
- Mixed text+file support  
- Metadata: MIME, byte length, checksum mode  

### 6.2. v2.2 — LLM Authenticity (when provider access is granted)
This unlocks the original dream:

- Fetch real conversation JSON from OpenAI/Claude backend APIs  
- Extract canonical prompt + response  
- Compare with user-provided Pair  
- Produce authenticated IA-HASH certificates  
- Detect manipulation or editing  
- Validate true origin of LLM outputs  

(Dependent on Cloudflare/OpenAI/Anthropic lifting restrictions.)

### 6.3. v2.3 — Adapter Ecosystem
- Expand `adapters/` with:
  - URL resolvers  
  - File loaders  
  - Git commit extractors  
  - S3 object adapters  
  - OCR-to-text pipelines  

### 6.4. v3.0 — Identity Layer (IHID)
- Each user can generate their own keypair  
- Dual-signature model:
  - User signs Pair  
  - IA-HASH (issuer) co-signs the certificate  
- Public registries  
- Revocation entries  
- Trust chains  

This enables:
- Authorship  
- Ownership  
- Legal signatures  
- Academic certification  
- Digital notarization  

### 6.5. v3.x — SDKs & CLI Tools
- Python SDK  
- JS/Node SDK  
- Rust/Go clients  
- `iahctl` CLI tool  
- Integrations with workflow engines (n8n, Temporal, etc.)

---

## 7. Project Status (Dec 2025)

### Stable branch: `v1.2`
- Fully functional  
- Feature-heavy  
- Architecture mixed  
- AI-centric  
- Hard to extend cleanly  

### Development branch: `v2`
- Clean architecture  
- Universal Pair protocol  
- Minimal API  
- Single-page UI  
- Legacy preserved  

### Production deployment
Once v2 reaches stability, Coolify can deploy it by simply switching branch.

---

## 8. Vision for IA-HASH

> IA-HASH is a universal integrity protocol for relationships between two meaningful elements.  
>  
> It is small, elegant, cryptographic, auditable, and provider-independent.  
>  
> The simplicity of Pairs unlocks a wide range of use cases:  
> technical, legal, scientific, personal, creative, and AI-related.

v2.0 is not a step backward —  
it is the moment where IA-HASH **discovers its true form**.

---

## 9. Summary

- IA-HASH evolves from “prompt+response verifier” to **universal Pair verification protocol**.  
- Architecture is cleaned, modular, and extensible.  
- Web/UI is simplified.  
- Legacy is preserved, not discarded.  
- Future-proof integrations will plug in cleanly when possible.  
- v2 is the foundation for everything that comes next.

**IA-HASH v2.0 = clarity, simplicity, universality, future-proofness.**
